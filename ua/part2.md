# 2. HTTP сьогодні

HTTP 1.1 перетворився на протокол, який використовується практично для всього в Інтернеті. Величезні інвестиції були вкладені в протоколи та інфраструктуру, яка цим користуються, настільки, що сьогодні часто простіше змусити щось працювати поверх HTTP, аніж будувати щось нове самостійно.

## 2.1 HTTP 1.1 величезний

Коли HTTP був створений та випущений у світ, він, ймовірно, сприймався як досить простий та зрозумілий протокол, але час довів, що це хибно. HTTP 1.0 у RFC 1945 це 60-и сторінкова специфікація, випущена у 1996. RFC 2616, що описує HTTP 1.1, була випущена лише через три роки, у 1999, і значно зросла, до 176 сторінок. Втім, коли ми в IETF працювали над оновленням до цієї специфікації, її було розділено та перетворено на шість документів зі значно більшою кількістю сторінок у цілому (вилилось у RFC 7230 та сімейство). За будь-яким підрахунком, HTTP 1.1 є великим, і включає міріади деталей, тонкощів і, що не менш важливо, багато опціональних частин.

## 2.2 Світ опцій

Природа HTTP 1.1 має безліч крихітних деталей та опцій, доступних для подальших розширень, переросла в екосистему програмного забезпечення де майже немає реалізації, яка, коли-небудь, реалізувала б усе - і насправді навіть неможливо точно сказати, що таке це «усе». Це призвело до ситуації, коли функціонал, який від самого початку мало використовувався, побачив дуже мало реалізацій і ті, хто впроваджував цей функціонал, потім спостерігав їх дуже незначне використання.

Згодом, це спричинило проблему сумісності, коли клієнти та сервери почали нарощувати використання подібного функціоналу. Конвеєризація HTTP (HTTP pipelining) є яскравим прикладом такого функціоналу.

## 2.3 Неадекватне використання TCP

HTTP 1.1 споживає надмірний час, щоб повною мірою скористатися усією потужністю та продуктивністю, що пропонує TCP. HTTP-клієнти та браузери, повинні бути дуже винахідливими, щоб знайти рішення, які зменшать час завантаження сторінки.

Інші спроби, які тривають паралельно протягом багатьох років, також підтвердили, що TCP не так легко замінити, і таким чином ми продовжуємо працювати над вдосконаленням як TCP, так і протоколів поверх нього.

Простіше кажучи, TCP можна використовувати краще, щоб уникнути пауз або втрачених інтервалів, які могли би бути використані для надсилання або отримання більшої кількості даних. Наступні розділи висвітлять деякі з цих недоліків.

## 2.4 Розміри передачі та кількість об'єктів

Якщо подивитись на тенденції деяких найпопулярніших вебсайтів сьогодні та що потрібно для завантаження зовнішньої частини їхніх сторінок, вимальовується чітка закономірність. З роками, обсяг даних, який потрібно отримати, поступово зріс до 1.9 МБ і більше. Що є більш важливим у цьому контексті, це те, що в середньому потрібно понад 100 індивідуальних ресурсів для відображення кожної сторінки.

Як показано на графіку нижче, ця тенденція триває вже певний час, і мало що свідчить про те, що це незабаром зміниться. Він показує зростання загального обсягу передачі (зеленим) та загальну кількість в середньому використаних запитів (червоним) для обслуговування найпопулярніших вебсайтів у світі та, як вони змінилися за останні чотири роки.

![зростання обсягу передачі](https://raw.githubusercontent.com/bagder/http2-explained/master/images/transfer-size-growth.png)

## 2.5 Затримка вбиває

<img style="float: right;" src="https://raw.githubusercontent.com/bagder/http2-explained/master/images/page-load-time-rtt-decreases.png" />

HTTP 1.1 дуже чутливий до затримок, частково через те, що конвеєризація HTTP (HTTP pipelining) все ще переповнена достатньою кількістю проблем, щоб залишатися вимкненою для великого відсотку користувачів.

Тоді як ми спостерігали значне збільшення доступної пропускної здатності для людей за останні кілька років, ми не спостерігали такого ж рівня покращень у зменшенні затримки. З'єднання з високою затримкою, як у багатьох сучасних мобільних технологіях, ускладнюють отримання хорошого та швидкого веб-досвіду, навіть якщо у вас з'єднання дуже високої пропускної здатності.

Інший варіант використання, який вимагає низької затримки, є певні види відео, як відеоконференції, геймінг і тому подібне, де немає заздалегідь просто створеного потоку для розсилки.

## 2.6. Блокування голови лінії (Head-of-line blocking)

Конвеєризація HTTP (HTTP pipelining) - це спосіб надіслати ще один запит під час очікування відповіді на попередній. Це дуже схоже на чергу за стійкою в банку чи супермаркеті: ви просто не знаєте, чи людина перед вами швидкий клієнт або ж той, надокучливий, що пройде вічність перш ніж він/вона закінчить. Це відомо як «блокування голови лінії» (head-of-line blocking).

<img style="float: right;" src="https://raw.githubusercontent.com/bagder/http2-explained/master/images/head-of-line-blocking.jpg" />

Звісно, ви можете спробувати обрати лінію, яку ви вважаєте правильною, а іноді ви навіть можете розпочати нову власну лінію. Але врешті-решт, вам не уникнути прийняття рішення. І як тільки це буде зроблено, ви не зможете змінити лінії.

Створення нової лінії, також пов'язане із втратою продуктивності та ресурсів, тому це не масштабується поза меншу кількість ліній. Для цього просто немає ідеального рішення.

Навіть сьогодні, за замовчуванням, більшість браузерів для настільних ПК постачаються з вимкненою конвеєризацією HTTP (HTTP pipelining).

Додаткові відомості, по цій темі, можна знайти на Firefox [bugzilla, запис 264354](https://bugzilla.mozilla.org/show_bug.cgi?id=264354).
